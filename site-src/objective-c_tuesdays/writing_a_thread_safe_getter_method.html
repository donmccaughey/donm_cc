<!doctype html>
<html lang=en>
<meta charset=utf-8>
<meta content='initial-scale=0.9, width=device-width' name=viewport>
<title>Writing A Thread Safe Getter Method</title>
<link href=/base.css rel=stylesheet>
<nav class=menu>
    <a href=/ >Don McCaughey</a> â€¢ <a href=/objective-c_tuesdays/ >Objective-C Tuesdays</a>
</nav>
<section>
    <h1>Writing A Thread Safe Getter Method</h1>
    <p>
        We've spent several weeks looking at how properties are defined and 
        created.  Last time we saw how to 
        <a href=/objective-c_tuesdays/changing_default_property_names.html>change 
        the default getter and setter names</a> and in the post before that we 
        learned about 
        <a href=/objective-c_tuesdays/atomic_and_nonatomic_properties.html>atomic 
        and nonatomic properties</a>.  Today we'll cover one final topic 
        related to properties: how to write a thread safe getter method.
    <p>
        In general, it's better to let the compiler generate your getters and 
        setters by using the <code>@synthesize</code> directive: it's less 
        error-prone and makes your class definitions shorter and easier to 
        read.  Sometimes however, you need to do something out of the ordinary 
        that <code>@synthesize</code> can't provide.  We covered 
        <a href=/objective-c_tuesdays/instance_variables_getters_and_setters.html>writing 
        getter and setter methods</a> in a previous post.  Those examples work 
        fine for single-threaded programs, and we looked at 
        <a href=/objective-c_tuesdays/atomic_and_nonatomic_properties.html>how 
        atomic getters and setters</a> are generated by the 
        <code>@synthesize</code> directive.  As is frequently the case with 
        multithreaded code, there is a subtle gotcha that occurs when 
        <code>retain</code>/<code>release</code> interacts with multiple 
        threads.
    <p>
        Let's use a very simple <code>Bookmark</code> class for a hypothetical 
        browser app as an example.  We'll try to make Bookmark objects 
        thread-safe so that the browser app can load preview images of 
        boomarked web sites in a background thread while the user edits 
        bookmarks in the main thread.
    <pre>@interface Bookmark : NSObject {
  NSURL *url;
  // ...
}
@property (retain) NSURL *url;
// ...
@end


@implementation Bookmark

- (NSURL *)url {
  NSURL *theUrl;
  @synchronized(self) {
    theUrl = url;
  }
  return theUrl;
}

- (void)setUrl:(NSURL *)theUrl {
  @synchronized(self) {
    if (theUrl != url) {
      [url release];
      url = [theUrl retain];
    }
  }
}

// ...
@end</pre>
    <p>
        Nothing very surprising here.  In the getter for <code>url</code>, the 
        temporary variable <code>theUrl</code> holds the pointer to the 
        <code>NSURL</code> object that the getter returns.  The 
        <code>@synchronized</code> block around the assignment <code>theUrl = 
        url</code>, along with a matching <code>@synchronized</code> block in 
        the setter, makes sure that the assignment is atomic.
    <p>
        Note that we use an explicit temporary variable in the getter, instead 
        of simply doing this:
    <pre>// WARNING: compiler complains about this
- (NSURL *)url {
  @synchronized(self) {
    return url;
  }
}</pre>
    <p>
        because the compiler complains about the return statement in the middle 
        of the <code>@synchronized</code> block.
    <p>
        With this getter and setter, we can set the URL from one thread while 
        getting it on another thread and never see an invalid value.  There's 
        still a thread safety issue here though.  Let's suppose that the 
        background thread is updating the thumbnails for our browser app while 
        the user decides to edit a bookmark.  Pseudo-code for these actions 
        might flow like this:
    <pre>// given Bookmark instance bookmark:

// background thread gets URL from bookmark
NSURL *thumbnailUrl = bookmark.url; // url is "example.com", retain count 1

// ... background thread preempted by main thread ...

                    // main thread sets new url value
                    bookmark.url = newUrl; // newUrl is "sample.com", retain count 1
                    // same as [bookmark setUrl:newUrl];
                    
                    // -setUrl: method called:
                    - (void)setUrl:(NSURL *)theUrl {
                      @synchronized(self) {
                        if (theUrl != url) {
                          [url release];         // "example.com" released
                                                 // retain count now 0, -dealloc called
                          url = [theUrl retain]; // "sample.com" retained
                                                 // retain count now 2
                        }
                      }
                    }

/// ... main thread preempted by background thread ...

// thumbnailUrl now points to a deallocated object
NSData *webPage = [NSData dataWithContentsOfURL:thumbnailUrl];
// a crash will happen sooner or later</pre>
    <p>
        Follow the retain counts of the old and new <code>NSURL</code> objects 
        in the pseudo-code above.  Even though the getter and setter for the 
        <code>url</code> property are atomic, using the <code>NSURL</code> 
        object returned by the getter isn't thread-safe since the setter can 
        cause the object to be deallocated while it's being used by code in 
        another thread.
    <p>
        In Cocoa and Cocoa Touch, when you receive an Objective-C object as a 
        return value from a method, there is an implicit promise that the 
        object will remain valid at least for the rest of the currently 
        executing function or method.  
    <p>
        But how does the <code>Bookmark</code> instance keep the original 
        <code>url</code> value alive after the setter is called?  By using the 
        autorelease pool.  Before returning the <code>NSURL</code> object from 
        the getter, we make the autorelease pool a second owner of the object.  
        If the <code>Bookmark</code> object then releases the <code>NSURL</code>
         for any reason, the autorelease pool will keep the <code>NSURL</code> 
        around until it is drained.  Since each thread has its own autorelease 
        pool, we don't need to worry about objects we're using being 
        deallocated in another thread.
    <p>
        Rewriting the getter to autorelease:
    <pre>- (NSURL *)url {
  NSURL *theUrl;
  @synchronized(self) {
    theUrl = [[url retain] autorelease];
  }
  return theUrl;
}</pre>
    <p>
        Note that we called <code>-retain</code> before calling 
        <code>-autorelease</code>.  I think of <code>-retain</code> as adding 
        an owner for an object, and <code>-release</code> as removing an owner. 
         The <code>-autorelease</code> method transfers the current ownership 
        to the autorelease pool, which will call <code>-release</code> as some 
        later time.  So <code>-retain</code> makes the <code>Bookmark</code> 
        object an owner twice, then <code>-autorelease</code> transfers one 
        ownership to the autorelease pool, giving us two owners of the 
        <code>NSURL</code> object.
    <p>
        So now the pseudo-code for the two threads interacting looks like this:
    <pre>// given Bookmark instance bookmark:

// background thread gets URL from bookmark
NSURL *url = bookmark.url; // url is "example.com", retain count 2
                           // 1 for bookmark, 1 for autorelease pool

// ... background thread preempted by main thread ...

                    // main thread sets new url value
                    bookmark.url = newUrl; // newUrl is "sample.com", retain count 1
                    // same as [bookmark setUrl:newUrl];
                    
                    // -setUrl: method called:
                    - (void)setUrl:(NSURL *)theUrl {
                      @synchronized(self) {
                        if (theUrl != url) {
                          [url release];         // "example.com" released
                                                 // retain count now 1
                          url = [theUrl retain]; // "sample.com" retained
                                                 // retain count now 2
                        }
                      }
                    }

/// ... main thread preempted by background thread ...

// url now owned only by autorelease pool, but that's okay
NSData *webPage = [NSData dataWithContentsOfURL:url];</pre>
    <p>
        When you use <code>@synthesize</code> to generate getters and setters, 
        the compiler generates thread-safe getters like this for you.  When 
        writing your own getters, it's a good practice to always retain and 
        autorelease any Objective-C object you returned.  Even if your code is 
        only single threaded, you can still hang yourself by trying to use an 
        object returned by a getter <em>after</em> calling the corresponding 
        getter:
    <pre>NSURL *oldUrl = bookmark.url;

bookmark.url = newUrl; // same as [bookmark setUrl:newUrl]
// oldUrl could be invalid if getter doesn't autorelease

NSLog(@"Replaced old URL %@ with new URL %@", oldUrl, newUrl);
// log statement might cause a crash</pre>
    <p>
        Next time, 
        <a href=/objective-c_tuesdays/variables_in_objective-c.html>a summary 
        of variables in Objective-C</a> and the start of a new topic: 
        <a href=/objective-c_tuesdays/c_strings.html>character strings</a>.
    <footer>
        <a href=http://blog.ablepear.com/2010/06/objective-c-tuesdays-writing-thread.html><em>Objective-C 
        Tuesdays: writing a thread safe getter method</em></a> was originally 
        published on <time datetime=2010-06-08>2010-06-08</time>.
    </footer>
</section>
